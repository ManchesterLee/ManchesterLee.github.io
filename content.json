{"pages":[{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"关于","text":"个人详细介绍","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Java内存泄漏排查","text":"任何使用Java开发应用的开发者都会或多或少遇到OOM（OutOfMemoryError），这个问题的产生源自我们对程序设计的不合理以及对象无法及时释放所占空间导致的。往往此类问题较难排查，需要分析JVM堆内存中对象进行分析才能准确的定位根据原因。本文将介绍一个开发过程中遇到的一个问题，并讲解如何利用JVM工具以及MAT进行问题排查。 什么是OOM在JVM没有足够的堆内存空间分配给新对象的时候，\b就会抛出java.lang.OutOfMemoryError错误。 为什么会发生OOM通常，在没有足够的空间在Java堆中分配对象时，会抛出此错误。在这种情况下，对象申请的内存空间超过堆内存剩余空间，垃圾收集器无法回收足够的空间，并且无法进一步扩展堆内存空间。在极少数情况下，当垃圾收集器花费过多的时间，且释放的内存很少也可能导致OOM。 排查思路假设在JVM内存空间足够的情况下发生了OOM，很可能就是代码中存在问题，导致对象所占空间无法被及时释放，从而引起应用发生OOM。所以需要分析JVM堆内存快照（heapdump），找出无法被释放的对象，确定问题发生的原因。 接下来用一个实际案例，讲述如何通过JVM工具以及MAT排查内存泄漏问题。 排查过程 程序执行一段时间后，抛出OOM错误，如下图。 开启VisualVM连接虚拟机，观察堆内存使用情况，可以发现内存使用持续增加。 通过jstat -gc观察虚拟机各分区垃圾回收情况。由图中可以看出年轻代回收次数很多，但是内存能够正常回收，但是老年代回收内存基本没有释放，反而使用空间更大（最后两条GC日志）。 然后通过jmap命令生成堆内存快照，通过MAT分析。这里可以看出，有可疑对象占用了1.4GB内存，接下来查看可疑的泄漏对象通过MAT的Leak Suspects（可疑的泄漏对象）发现，共有955个com.alibaba.fastjson.JSONObject对象占用了91.85%的内存空间。从这里能够看出来应该是这个com.alibaba.fastjson.JSONObject无法及时释放，导致的内存泄漏问题。那么为什么这些对象为什么无法被回收呢？ 接下来通过MAT的Dominator Tree分析对象引用关系。从图中可以看出，内存中有非常多的com.alibaba.fastjson.JSONObject对象实例。随机选中\b一个实例，通过右键观察持有该对象引用的对象(list -&gt; Incoming References)。 通过图中可以看出该对象被三个对象引用，而这三个对象又分别被别的对象引用，引用关系如下： ArrayList @ 0x835c2110 HashMap @ 0x846e7608 Thread @ 0x8221e450 main ArrayList @ 0x841a04b8 HashMap @ 0x83d64de0 Thread @ 0x83ecb138 data-sort-6 Thread @ 0x84056440 data-sort-4 Thread @ 0x840568a8 data-sort-1 ArrayList @ 0x846e75f0 Thread @ 0x8221e450 main 由此可以看出，该对象被三个ArrayList对象持有引用，且这三个ArrayList中的两个直接和间接的被Thread main持有引用，另一个ArrayList对象被三个子线程间接持有引用，由于子线程执行完毕之后会释放对象引用，故排除子线程。接下来主要观察主线程对该对象引用的持有情况，由于存在两出引用关系，且在主线程中分别被\bHashMap和ArrayList对象直接持有，故在代码中寻找两处引用的地方，最后发现，由于开发人员只释放了\bHashMap对com.alibaba.fastjson.JSONObject的引用，而ArrayList并没有释放，最终导致程序在执行一段时间之后产生OOM错误。","link":"/2019/01/29/Java内存泄漏排查/"},{"title":"Maven多模块-Spring Boot项目","text":"在开发过程中，为了方便我们可能会将所有的代码都放在一个项目中，所有人的工作内容都集中在一起。随着业务的快速发展，会导致整个项目越来越复杂和后期维护难等问题。而项目模块化可以更好的实现代码复用，简化项目结构，使逻辑更加清晰，也方便团队分工合作，后期扩展和维护。 本文将以一个个人博客项目为例，简单讲解如何搭建一个基于Spring Boot的Maven多模块项目。 环境： JDK Maven(3.3.9) Intellij IDEA 1. 首先创建一个Spring Boot父项目注意Type类型选择pom 项目结构如下图所示pom配置文件修改成如图所示。图中标出的两个文件夹是用来存放子项目，library用来存放依赖的项目，application用来存放应用，当然也可以选择直接放在根目录。 2. 创建子项目右键父项目，选择New，然后选择Module，注意选择Maven类型项目继续下一步这里把blog-web项目放在了application文件夹，可以选择放在根目录，没有影响。 创建好直接项目结构如下由于这里当前项目放在application文件夹内，所以blog-web中pom文件中的relativePath的配置如图所示。若子项目放在根目录，则配置略有不同，应该是../pom.xml。 修改blog-web的pom文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-web&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;artifactId&gt;blog-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 接下来依次创建service和dao模块，具体过程就不一一解释了，流程和上面叙述的相同，主要看下每个项目的pom文件的配置。 blog-service的pom文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;artifactId&gt;blog-dao&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; blog-dao的pom文件 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-dao&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 项目成功运行！！！ 完整代码在GitHub上，有需要的同学可以自行下载。 注意：blog-dao的application.yml文件放在classpath:config下面，是为了避免配置被覆盖，导致读取不到相关配置的问题。","link":"/2018/11/24/Maven多模块-SpringBoot项目/"},{"title":"Spring Boot源码分析-配置文件加载原理","text":"Spring Boot是目前最流行的Java开发框架，它提供了很多的默认配置，不需要我们再去逐一配置，极大地简化了开发流程。项目中的部分具体配置值一般都写在application.properties或application.yml中，本文就让我们一起来探讨一下Spring Boot如何加载配置文件中的内容。 本文针对有一定Spring Boot使用基础的同学，才能更好地理解后面叙述的内容。 基于Spring Boot 1.5.6.RELEASE版本 首先让我们了解一下Spring Boot 简介（以下内容来自百度百科） Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 Spring Boot特性 约定优于配置，大多数的配置直接使用默认配置即可 快速搭建项目，脱离繁杂的XML配置 内嵌Servlet容器，不依赖外部容器 与云计算天然集成，提供主流框架一键集成方式 接下来，进入正题通过源码分析理解Spring Boot加载配置文件内容的过程（部分方法内容没有贴出，可以根据源码一步一步跟踪下去）。 所有的Spring Boot项目都是由SpringApplication.run()这个静态方法开始执行的，源码分析也从这里开始进行。123public static ConfigurableApplicationContext run(Object source, String... args) { return run(new Object[] { source }, args);} run()方法内部实际上构造了一个SpringApplication对象并执行对象的run()方法（非静态方法）123public static ConfigurableApplicationContext run(Object[] sources, String[] args) { return new SpringApplication(sources).run(args);} 可以看到构造方法里面执行了initialize()方法12345678910111213private void initialize(Object[] sources) { if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } // 判断当前是否是web环境 this.webEnvironment = deduceWebEnvironment(); // 初始化ApplicationContextInitializer对象 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 初始化ApplicationListener对象 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass();} 这里可以看到是通过getSpringFactoriesInstances()初始化相关对象，进入方法内部123456789101112private &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // 加载类名称 Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 创建对象 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances;} 进入SpringFactoriesLoader.loadFactoryNames()方法，看加载哪些类123456789101112131415161718192021public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); } return result; } catch (IOException ex) { throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() + \"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); }} 可以看到实际上是加载META-INF/spring.factories文件夹下的内容，读取到的内容放在Properties中，通过类的名称去获取对应的值。值就是实现类的名称，然后再调用createSpringFactoriesInstances创建相关类的实例，这样就完成了对ApplicationContextInitializer对象的实例化工作。同理ApplicationListener。 那么META-INF/spring.factories这个文件放在哪里呢，我们的项目下一般是不存在这个文件的。 实际上这个文件存在于Spring Boot项目中，这里就体现了Spring Boot的默认配置，文件内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader=\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\org.springframework.boot.context.ContextIdApplicationContextInitializer,\\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\org.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.ClearCachesApplicationListener,\\org.springframework.boot.builder.ParentContextCloserApplicationListener,\\org.springframework.boot.context.FileEncodingApplicationListener,\\org.springframework.boot.context.config.AnsiOutputApplicationListener,\\org.springframework.boot.context.config.ConfigFileApplicationListener,\\org.springframework.boot.context.config.DelegatingApplicationListener,\\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\\org.springframework.boot.logging.ClasspathLoggingApplicationListener,\\org.springframework.boot.logging.LoggingApplicationListener# Environment Post Processorsorg.springframework.boot.env.EnvironmentPostProcessor=\\org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor# Failure Analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\\org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.NoSuchMethodFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer# FailureAnalysisReportersorg.springframework.boot.diagnostics.FailureAnalysisReporter=\\org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter 接下来，继续看run()方法1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); // 实例化SpringApplicationRunListener对象 SpringApplicationRunListeners listeners = getRunListeners(args); // 广播ApplicationStartedEvent事件 listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} 这里需要关注getRunListeners()这个方法12345private SpringApplicationRunListeners getRunListeners(String[] args) { Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class }; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args));} 根据前面分析的代码可以看出，这里构造了SpringApplicationRunListener对象，对应的实现类即是EventPublishingRunListener，这个对象提供了广播Spring事件的能力。123# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener 再看listeners.starting()，实际上就是执行了EventPublishingRunListener.starting()方法，这个方法广播了一个ApplicationEnvironmentPreparedEvent事件。 到这里才真正开始进入读取配置的环节，前面的都是铺垫。通过观察可以看出ConfigFileApplicationListener监听了ApplicationEnvironmentPreparedEvent事件。那么在接收到这个事件的通知之后，又做了什么呢？ 继续往下看… 1234567891011121314151617181920public void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { onApplicationEnvironmentPreparedEvent( (ApplicationEnvironmentPreparedEvent) event); } if (event instanceof ApplicationPreparedEvent) { onApplicationPreparedEvent(event); }}private void onApplicationEnvironmentPreparedEvent( ApplicationEnvironmentPreparedEvent event) { List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors(); postProcessors.add(this); AnnotationAwareOrderComparator.sort(postProcessors); for (EnvironmentPostProcessor postProcessor : postProcessors) { postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication()); }} 这里可以看到执行了onApplicationEnvironmentPreparedEvent()方法。首先加载通过SpringFactoriesLoader.loadFactories()加载对应的Processor，然后将ConfigFileApplicationListener也添加到了postProcessors中。原来它也实现了EnvironmentPostProcessor接口。123public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {} 紧接着执行每个Processor的postProcessEnvironment()方法。这里我们主要关注ConfigFileApplicationListener.postProcessEnvironment()方法。123456789101112public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { addPropertySources(environment, application.getResourceLoader()); configureIgnoreBeanInfo(environment); bindToSpringApplication(environment, application);}protected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) { RandomValuePropertySource.addToEnvironment(environment); // load方法才真正实现加载配置文件内容 new Loader(environment, resourceLoader).load();} 继续跟踪Loader.load()方法123456789101112131415161718192021222324252627282930313233343536public void load() { this.propertiesLoader = new PropertySourcesLoader(); this.activatedProfiles = false; this.profiles = Collections.asLifoQueue(new LinkedList&lt;Profile&gt;()); this.processedProfiles = new LinkedList&lt;Profile&gt;(); Set&lt;Profile&gt; initialActiveProfiles = initializeActiveProfiles(); this.profiles.addAll(getUnprocessedActiveProfiles(initialActiveProfiles)); if (this.profiles.isEmpty()) { for (String defaultProfileName : this.environment.getDefaultProfiles()) { Profile defaultProfile = new Profile(defaultProfileName, true); if (!this.profiles.contains(defaultProfile)) { this.profiles.add(defaultProfile); } } } this.profiles.add(null); while (!this.profiles.isEmpty()) { Profile profile = this.profiles.poll(); for (String location : getSearchLocations()) { if (!location.endsWith(\"/\")) { load(location, null, profile); } else { for (String name : getSearchNames()) { load(location, name, profile); } } } this.processedProfiles.add(profile); } addConfigurationProperties(this.propertiesLoader.getPropertySources());} 这里先不考虑profile的影响，直接看while循环里面且套的foreach循环，进入getSearchLocations()12345678910111213141516171819202122public static final String CONFIG_LOCATION_PROPERTY = \"spring.config.location\";private static final String DEFAULT_SEARCH_LOCATIONS = \"classpath:/,classpath:/config/,file:./,file:./config/\";private Set&lt;String&gt; getSearchLocations() { Set&lt;String&gt; locations = new LinkedHashSet&lt;String&gt;(); // 判断是否修改了配置文件的默认位置 if (this.environment.containsProperty(CONFIG_LOCATION_PROPERTY)) { for (String path : asResolvedSet( this.environment.getProperty(CONFIG_LOCATION_PROPERTY), null)) { if (!path.contains(\"$\")) { path = StringUtils.cleanPath(path); if (!ResourceUtils.isUrl(path)) { path = ResourceUtils.FILE_URL_PREFIX + path; } } locations.add(path); } } locations.addAll( asResolvedSet(ConfigFileApplicationListener.this.searchLocations, DEFAULT_SEARCH_LOCATIONS)); return locations;} 从DEFAULT_SEARCH_LOCATIONS可以看出，通常情况下，这个四个位置的配置文件会被默认加载。在回到load()方法里面的foreach循环，会执行123for (String name : getSearchNames()) { load(location, name, profile);} 在进入getSearchNames()方法12345678private static final String DEFAULT_NAMES = \"application\";private Set&lt;String&gt; getSearchNames() { if (this.environment.containsProperty(CONFIG_NAME_PROPERTY)) { return asResolvedSet(this.environment.getProperty(CONFIG_NAME_PROPERTY), null); } return asResolvedSet(ConfigFileApplicationListener.this.names, DEFAULT_NAMES);} 这里的ConfigFileApplicationListener.this.names是null，所以返回的就是DEFAULT_NAMES。所以，这就是为什么默认配置文件名称都是application。拿到文件名称后，在回到上面的forech方法，执行了load()方法，name即是文件名称12345678910111213141516171819202122232425private void load(String location, String name, Profile profile) { String group = \"profile=\" + ((profile != null) ? profile : \"\"); if (!StringUtils.hasText(name)) { loadIntoGroup(group, location, profile); } else { // 支持的文件类型是properties，xml，yml等文件格式 for (String ext : this.propertiesLoader.getAllFileExtensions()) { if (profile != null) { loadIntoGroup(group, location + name + \"-\" + profile + \".\" + ext, null); for (Profile processedProfile : this.processedProfiles) { if (processedProfile != null) { loadIntoGroup(group, location + name + \"-\" + processedProfile + \".\" + ext, profile); } } loadIntoGroup(group, location + name + \"-\" + profile + \".\" + ext, profile); } // 加载配置文件 loadIntoGroup(group, location + name + \".\" + ext, profile); } }} 再进入loadIntoGroup方法1234567891011121314151617181920212223242526272829303132333435private PropertySource&lt;?&gt; doLoadIntoGroup(String identifier, String location, Profile profile) throws IOException { Resource resource = this.resourceLoader.getResource(location); PropertySource&lt;?&gt; propertySource = null; StringBuilder msg = new StringBuilder(); if (resource != null &amp;&amp; resource.exists()) { String name = \"applicationConfig: [\" + location + \"]\"; String group = \"applicationConfig: [\" + identifier + \"]\"; propertySource = this.propertiesLoader.load(resource, group, name, (profile != null) ? profile.getName() : null); if (propertySource != null) { msg.append(\"Loaded \"); handleProfileProperties(propertySource); } else { msg.append(\"Skipped (empty) \"); } } else { msg.append(\"Skipped \"); } msg.append(\"config file \"); msg.append(getResourceDescription(location, resource)); if (profile != null) { msg.append(\" for profile \").append(profile); } if (resource == null || !resource.exists()) { msg.append(\" resource not found\"); this.logger.trace(msg); } else { this.logger.debug(msg); } return propertySource;} 可以看到这里是通过this.propertiesLoader.load()方法读取配置12345678910111213141516public PropertySource&lt;?&gt; load(Resource resource, String group, String name, String profile) throws IOException { if (isFile(resource)) { String sourceName = generatePropertySourceName(name, profile); for (PropertySourceLoader loader : this.loaders) { // 判断当前loader是否能读取该类型文件 if (canLoadFileExtension(loader, resource)) { PropertySource&lt;?&gt; specific = loader.load(sourceName, resource, profile); addPropertySource(group, specific); return specific; } } } return null;} 然后又通过loader.load()方法执行具体的读取逻辑123456public PropertySourcesLoader(MutablePropertySources propertySources) { Assert.notNull(propertySources, \"PropertySources must not be null\"); this.propertySources = propertySources; this.loaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class, getClass().getClassLoader());} 结合META-INF/spring.factories，可以看出loaders实际上PropertiesPropertySourceLoader和YamlPropertySourceLoader对象。 我们看下PropertiesPropertySourceLoader的load方法。12345678910public PropertySource&lt;?&gt; load(String name, Resource resource, String profile) throws IOException { if (profile == null) { Properties properties = PropertiesLoaderUtils.loadProperties(resource); if (!properties.isEmpty()) { return new PropertiesPropertySource(name, properties); } } return null;} 由PropertiesLoaderUtils.loadProperties()方法将配置文件中的内容读取写入到Properties对象里，到这里已经执行了Spring Boot对配置文件内容的读取。 总结整个源码分析的过程还是很长的，牵涉到很多的类，中间的关系还是有点复杂。不过如果第一遍看不懂的话，可以多看几遍，多跟踪几遍源码，每次你都会多明白一些原理，看到后面自然就明白其中的原理了。这里为了简化分析，忽略了其他一部分因素的影响，例如profile等。虽然看源码的过程比较枯燥繁琐，且懂不懂源码对业务开发没有明显的影响，但是如果你想突破自己，提升自己，阅读优秀源码是一门必修的课程。","link":"/2018/11/25/SpringBoot源码分析-配置文件加载原理/"},{"title":"设计模式-责任链","text":"责任链设计模式是一种行为模式，其中一组对象按顺序连接在一起，请求在对象链上传递，直到有一个对象处理该请求，返回一个响应对象。否则该请求将继续往下传递。 什么是责任链模式为了更好的理解该责任链模式，举一个现实生活中的例子。假设你手中有一个难题，首先你会尝试自己去解决，如果自己无法解决，你会告诉你的一个朋友请求他解决，如果他也无法解决，则他会将该问题传递给下一个朋友去解决，直到有一个人解决了该难题，或者没有人解决。 责任链模式的意图是避免将请求的发送者和接收者耦合在一起，让每一个接收者都有机会处理该请求。将接收者按顺序连接在一起，并将请求在这条链上往下传递，直到有一个对象处理了该请求。 Handler处理请求的接口 ConcreteHandler处理请求的对象 Client初始化请求并将请求传递到Handler对象链 实现Handler表示处理请求对象 1234567public interface Handler { void process(File file); String name();} TextFileHandler可以处理文本类文件 1234567891011121314151617181920212223public class TextFileHandler implements Handler { private Handler handler; public TextFileHandler(Handler handler) { this.handler = handler; } @Override public void process(File file) { if (\"text\".equals(file.getType())) { System.out.println(file.getName() + \" was handled by \" + name()); } else if (handler != null) { handler.process(file); } else { System.out.println(file.getName() + \" is not supported\"); } } @Override public String name() { return \"textFileHandler\"; }} ImageFileHandler可以处理图像类文件 1234567891011121314151617181920212223public class ImageFileHandler implements Handler { private Handler handler; public ImageFileHandler(Handler handler) { this.handler = handler; } @Override public void process(File file) { if (\"image\".equals(file.getType())) { System.out.println(file.getName() + \" was handled by \" + name()); } else if (handler != null) { handler.process(file); } else { System.out.println(file.getName() + \" is not supported\"); } } @Override public String name() { return \"imageFileHandler\"; }} File表示被处理的请求 1234567891011121314151617181920212223242526272829303132public interface File { String getName(); String getType();}// 图像文件public class ImageFile implements File { @Override public String getName() { return \"imageFile\"; } @Override public String getType() { return \"image\"; }}// 文本文件public class TextFile implements File { @Override public String getName() { return \"textFile\"; } @Override public String getType() { return \"text\"; }} 12345678910111213public class Client { public static void main(String[] args) { ImageFileHandler imageFileHandler = new ImageFileHandler(null); TextFileHandler textFileHandler = new TextFileHandler(imageFileHandler); TextFile textFile = new TextFile(); ImageFile imageFile = new ImageFile(); textFileHandler.process(textFile); textFileHandler.process(imageFile); }} 测试程序输出内容 textFile was handled by textFileHandler textFileHandler could not handle imageFile imageFile was handled by imageFileHandler 在上述代码中，文件先交由TextFileHandler处理，若其无法处理则传递到下一个ImageFileHandler处理。 对于TextFile，TextFileHandler直接处理该文件，所以不会再往下传递。 而对于ImageFile，TextFileHandler无法处理，则传递到ImageFileHandler处理。","link":"/2018/10/31/设计模式-责任链/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"MAT","slug":"MAT","link":"/tags/MAT/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/内存泄漏/"},{"name":"内存溢出","slug":"内存溢出","link":"/tags/内存溢出/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"}],"categories":[{"name":"Maven","slug":"Maven","link":"/categories/Maven/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"}]}