{"pages":[],"posts":[{"title":"Maven多模块-Spring Boot项目","text":"在开发过程中，为了方便我们可能会将所有的代码都放在一个项目中，所有人的工作内容都集中在一起。随着业务的快速发展，会导致整个项目越来越复杂和后期维护难等问题。而项目模块化可以更好的实现代码复用，简化项目结构，使逻辑更加清晰，也方便团队分工合作，后期扩展和维护。 本文将以一个个人博客项目为例，简单讲解如何搭建一个基于Spring Boot的Maven多模块项目。 环境： JDK Maven(3.3.9) Intellij IDEA 1. 首先创建一个Spring Boot父项目注意Type类型选择pom 项目结构如下图所示pom配置文件修改成如图所示。图中标出的两个文件夹是用来存放子项目，library用来存放依赖的项目，application用来存放应用，当然也可以选择直接放在根目录。 2. 创建子项目右键父项目，选择New，然后选择Module，注意选择Maven类型项目继续下一步这里把blog-web项目放在了application文件夹，可以选择放在根目录，没有影响。 创建好直接项目结构如下由于这里当前项目放在application文件夹内，所以blog-web中pom文件中的relativePath的配置如图所示。若子项目放在根目录，则配置略有不同，应该是../pom.xml。 修改blog-web的pom文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-web&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;artifactId&gt;blog-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 接下来依次创建service和dao模块，具体过程就不一一解释了，流程和上面叙述的相同，主要看下每个项目的pom文件的配置。 blog-service的pom文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;artifactId&gt;blog-dao&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; blog-dao的pom文件 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-dao&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 项目成功运行！！！ 完整代码在GitHub上，有需要的同学可以自行下载。 注意：blog-dao的application.yml文件放在classpath:config下面，是为了避免配置被覆盖，导致读取不到相关配置的问题。","link":"/2018/11/24/Maven多模块-SpringBoot项目/"},{"title":"设计模式-责任链","text":"责任链设计模式是一种行为模式，其中一组对象按顺序连接在一起，请求在对象链上传递，直到有一个对象处理该请求，返回一个响应对象。否则该请求将继续往下传递。 什么是责任链模式为了更好的理解该责任链模式，举一个现实生活中的例子。假设你手中有一个难题，首先你会尝试自己去解决，如果自己无法解决，你会告诉你的一个朋友请求他解决，如果他也无法解决，则他会将该问题传递给下一个朋友去解决，直到有一个人解决了该难题，或者没有人解决。 责任链模式的意图是避免将请求的发送者和接收者耦合在一起，让每一个接收者都有机会处理该请求。将接收者按顺序连接在一起，并将请求在这条链上往下传递，直到有一个对象处理了该请求。 Handler处理请求的接口 ConcreteHandler处理请求的对象 Client初始化请求并将请求传递到Handler对象链 实现Handler表示处理请求对象 1234567public interface Handler { void process(File file); String name();} TextFileHandler可以处理文本类文件 1234567891011121314151617181920212223public class TextFileHandler implements Handler { private Handler handler; public TextFileHandler(Handler handler) { this.handler = handler; } @Override public void process(File file) { if (\"text\".equals(file.getType())) { System.out.println(file.getName() + \" was handled by \" + name()); } else if (handler != null) { handler.process(file); } else { System.out.println(file.getName() + \" is not supported\"); } } @Override public String name() { return \"textFileHandler\"; }} ImageFileHandler可以处理图像类文件 1234567891011121314151617181920212223public class ImageFileHandler implements Handler { private Handler handler; public ImageFileHandler(Handler handler) { this.handler = handler; } @Override public void process(File file) { if (\"image\".equals(file.getType())) { System.out.println(file.getName() + \" was handled by \" + name()); } else if (handler != null) { handler.process(file); } else { System.out.println(file.getName() + \" is not supported\"); } } @Override public String name() { return \"imageFileHandler\"; }} File表示被处理的请求 1234567891011121314151617181920212223242526272829303132public interface File { String getName(); String getType();}// 图像文件public class ImageFile implements File { @Override public String getName() { return \"imageFile\"; } @Override public String getType() { return \"image\"; }}// 文本文件public class TextFile implements File { @Override public String getName() { return \"textFile\"; } @Override public String getType() { return \"text\"; }} 1234567891011121314public class Client { public static void main(String[] args) { ImageFileHandler imageFileHandler = new ImageFileHandler(null); TextFileHandler textFileHandler = new TextFileHandler(imageFileHandler); TextFile textFile = new TextFile(); ImageFile imageFile = new ImageFile(); textFileHandler.process(textFile); textFileHandler.process(imageFile); }} 测试程序输出内容 textFile was handled by textFileHandler textFileHandler could not handle imageFile imageFile was handled by imageFileHandler 在上述代码中，文件先交由TextFileHandler处理，若其无法处理则传递到下一个ImageFileHandler处理。 对于TextFile，TextFileHandler直接处理该文件，所以不会再往下传递。 而对于ImageFile，TextFileHandler无法处理，则传递到ImageFileHandler处理。","link":"/2018/10/31/设计模式-责任链/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"}],"categories":[{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"}]}