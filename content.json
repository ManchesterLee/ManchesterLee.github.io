{"pages":[],"posts":[{"title":"Maven多模块-Spring Boot项目","text":"在开发过程中，为了方便我们可能会将所有的代码都放在一个项目中，所有人的工作内容都集中在一起。随着业务的快速发展，会导致整个项目越来越复杂和后期维护难等问题。而项目模块化可以更好的实现代码复用，简化项目结构，使逻辑更加清晰，也方便团队分工合作，后期扩展和维护。 本文将以一个个人博客项目为例，简单讲解如何搭建一个基于Spring Boot的Maven多模块项目。 环境： JDK Maven(3.3.9) Intellij IDEA 1. 首先创建一个Spring Boot父项目注意Type类型选择pom 项目结构如下图所示pom配置文件修改成如图所示。图中标出的两个文件夹是用来存放子项目，library用来存放依赖的项目，application用来存放应用，当然也可以选择直接放在根目录。 2. 创建子项目右键父项目，选择New，然后选择Module，注意选择Maven类型项目继续下一步这里把blog-web项目放在了application文件夹，可以选择放在根目录，没有影响。 创建好直接项目结构如下由于这里当前项目放在application文件夹内，所以blog-web中pom文件中的relativePath的配置如图所示。若子项目放在根目录，则配置略有不同，应该是../pom.xml。 修改blog-web的pom文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-web&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;artifactId&gt;blog-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 接下来依次创建service和dao模块，具体过程就不一一解释了，流程和上面叙述的相同，主要看下每个项目的pom文件的配置。 blog-service的pom文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;artifactId&gt;blog-dao&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; blog-dao的pom文件 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-multi-module&lt;/artifactId&gt; &lt;groupId&gt;io.example&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;blog-dao&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 项目成功运行！！！ 完整代码在GitHub上，有需要的同学可以自行下载。 注意：blog-dao的application.yml文件放在classpath:config下面，是为了避免配置被覆盖，导致读取不到相关配置的问题。","link":"/2018/11/24/Maven多模块-SpringBoot项目/"},{"title":"设计模式-责任链","text":"责任链设计模式是一种行为模式，其中一组对象按顺序连接在一起，请求在对象链上传递，直到有一个对象处理该请求，返回一个响应对象。否则该请求将继续往下传递。 什么是责任链模式为了更好的理解该责任链模式，举一个现实生活中的例子。假设你手中有一个难题，首先你会尝试自己去解决，如果自己无法解决，你会告诉你的一个朋友请求他解决，如果他也无法解决，则他会将该问题传递给下一个朋友去解决，直到有一个人解决了该难题，或者没有人解决。 责任链模式的意图是避免将请求的发送者和接收者耦合在一起，让每一个接收者都有机会处理该请求。将接收者按顺序连接在一起，并将请求在这条链上往下传递，直到有一个对象处理了该请求。 Handler处理请求的接口 ConcreteHandler处理请求的对象 Client初始化请求并将请求传递到Handler对象链 实现Handler表示处理请求对象 1234567public interface Handler { void process(File file); String name();} TextFileHandler可以处理文本类文件 1234567891011121314151617181920212223public class TextFileHandler implements Handler { private Handler handler; public TextFileHandler(Handler handler) { this.handler = handler; } @Override public void process(File file) { if (\"text\".equals(file.getType())) { System.out.println(file.getName() + \" was handled by \" + name()); } else if (handler != null) { handler.process(file); } else { System.out.println(file.getName() + \" is not supported\"); } } @Override public String name() { return \"textFileHandler\"; }} ImageFileHandler可以处理图像类文件 1234567891011121314151617181920212223public class ImageFileHandler implements Handler { private Handler handler; public ImageFileHandler(Handler handler) { this.handler = handler; } @Override public void process(File file) { if (\"image\".equals(file.getType())) { System.out.println(file.getName() + \" was handled by \" + name()); } else if (handler != null) { handler.process(file); } else { System.out.println(file.getName() + \" is not supported\"); } } @Override public String name() { return \"imageFileHandler\"; }} File表示被处理的请求 1234567891011121314151617181920212223242526272829303132public interface File { String getName(); String getType();}// 图像文件public class ImageFile implements File { @Override public String getName() { return \"imageFile\"; } @Override public String getType() { return \"image\"; }}// 文本文件public class TextFile implements File { @Override public String getName() { return \"textFile\"; } @Override public String getType() { return \"text\"; }} 12345678910111213public class Client { public static void main(String[] args) { ImageFileHandler imageFileHandler = new ImageFileHandler(null); TextFileHandler textFileHandler = new TextFileHandler(imageFileHandler); TextFile textFile = new TextFile(); ImageFile imageFile = new ImageFile(); textFileHandler.process(textFile); textFileHandler.process(imageFile); }} 测试程序输出内容 textFile was handled by textFileHandler textFileHandler could not handle imageFile imageFile was handled by imageFileHandler 在上述代码中，文件先交由TextFileHandler处理，若其无法处理则传递到下一个ImageFileHandler处理。 对于TextFile，TextFileHandler直接处理该文件，所以不会再往下传递。 而对于ImageFile，TextFileHandler无法处理，则传递到ImageFileHandler处理。","link":"/2018/10/31/设计模式-责任链/"},{"title":"Spring Boot源码分析-配置文件加载原理","text":"Spring Boot框架提供了很多的默认配置，不需要我们再去逐一配置，极大地简化了开发流程，但是还是有部分配置是无法提供默认值得，这时候就需要我们自己手动配置。一般情况下，我们的配置都是写在application.properties或application.yml中，本文就让我们一起来探讨一下Spring Boot如何加载配置文件中的内容。 本文针对有一定Spring Boot使用基础的同学，才能更好地理解后面叙述的内容。 基于Spring Boot`1.5.6.RELEASE`版本 首先让我们了解一下Spring Boot 简介（以下内容来自百度百科） Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 Spring Boot特性 约定优于配置，大多数的配置直接使用默认配置即可 快速搭建项目，脱离繁杂的XML配置 内嵌Servlet容器，不依赖外部容器 与云计算天然集成，提供主流框架一键集成方式 接下来，进入正题通过源码分析理解Spring Boot加载配置文件内容的过程（部分方法内容没有贴出，可以根据源码一步一步跟踪下去）。 所有的Spring Boot项目都是由SpringApplication.run()这个静态方法开始执行的，源码分析也从这里开始进行。123public static ConfigurableApplicationContext run(Object source, String... args) { return run(new Object[] { source }, args);} run()方法内部实际上构造了一个SpringApplication对象并执行对象的run()方法（非静态方法）123public static ConfigurableApplicationContext run(Object[] sources, String[] args) { return new SpringApplication(sources).run(args);} 可以看到构造方法里面执行了initialize()方法12345678910111213private void initialize(Object[] sources) { if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } // 判断当前是否是web环境 this.webEnvironment = deduceWebEnvironment(); // 初始化ApplicationContextInitializer对象 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 初始化ApplicationListener对象 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass();} 这里可以看到是通过getSpringFactoriesInstances()初始化相关对象，进入方法内部123456789101112private &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // 加载类名称 Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;( SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 创建对象 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); AnnotationAwareOrderComparator.sort(instances); return instances;} 进入SpringFactoriesLoader.loadFactoryNames()方法，看加载哪些类123456789101112131415161718192021public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); try { Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) { URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); } return result; } catch (IOException ex) { throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() + \"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); }} 可以看到实际上是加载META-INF/spring.factories文件夹下的内容，读取到的内容放在Properties中，通过类的名称去获取对应的值。值就是实现类的名称，然后再调用createSpringFactoriesInstances创建相关类的实例，这样就完成了对ApplicationContextInitializer对象的实例化工作。同理ApplicationListener。 那么META-INF/spring.factories这个文件放在哪里呢，我们的项目下一般是不存在这个文件的。 实际上这个文件存在于Spring Boot项目中，这里就体现了Spring Boot的默认配置，文件内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader=\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\org.springframework.boot.context.ContextIdApplicationContextInitializer,\\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\org.springframework.boot.context.embedded.ServerPortInfoApplicationContextInitializer# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.ClearCachesApplicationListener,\\org.springframework.boot.builder.ParentContextCloserApplicationListener,\\org.springframework.boot.context.FileEncodingApplicationListener,\\org.springframework.boot.context.config.AnsiOutputApplicationListener,\\org.springframework.boot.context.config.ConfigFileApplicationListener,\\org.springframework.boot.context.config.DelegatingApplicationListener,\\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\\org.springframework.boot.logging.ClasspathLoggingApplicationListener,\\org.springframework.boot.logging.LoggingApplicationListener# Environment Post Processorsorg.springframework.boot.env.EnvironmentPostProcessor=\\org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor# Failure Analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\\org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.NoSuchMethodFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\\org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer# FailureAnalysisReportersorg.springframework.boot.diagnostics.FailureAnalysisReporter=\\org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter 接下来，继续看run()方法1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); // 实例化SpringApplicationRunListener对象 SpringApplicationRunListeners listeners = getRunListeners(args); // 广播ApplicationStartedEvent事件 listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} 这里需要关注getRunListeners()这个方法12345private SpringApplicationRunListeners getRunListeners(String[] args) { Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class }; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances( SpringApplicationRunListener.class, types, this, args));} 根据前面分析的代码可以看出，这里构造了SpringApplicationRunListener对象，对应的实现类即是EventPublishingRunListener，这个对象提供了广播Spring事件的能力。123# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener 再看listeners.starting()，实际上就是执行了EventPublishingRunListener.starting()方法，这个方法广播了一个ApplicationEnvironmentPreparedEvent事件。 到这里才真正开始进入读取配置的环节，前面的都是铺垫。通过观察可以看出ConfigFileApplicationListener监听了ApplicationEnvironmentPreparedEvent事件。那么在接收到这个事件的通知之后，又做了什么呢？ 继续往下看… 1234567891011121314151617181920public void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { onApplicationEnvironmentPreparedEvent( (ApplicationEnvironmentPreparedEvent) event); } if (event instanceof ApplicationPreparedEvent) { onApplicationPreparedEvent(event); }}private void onApplicationEnvironmentPreparedEvent( ApplicationEnvironmentPreparedEvent event) { List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors(); postProcessors.add(this); AnnotationAwareOrderComparator.sort(postProcessors); for (EnvironmentPostProcessor postProcessor : postProcessors) { postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication()); }} 这里可以看到执行了onApplicationEnvironmentPreparedEvent()方法。首先加载通过SpringFactoriesLoader.loadFactories()加载对应的Processor，然后将ConfigFileApplicationListener也添加到了postProcessors中。原来它也实现了EnvironmentPostProcessor接口。123public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered {} 紧接着执行每个Processor的postProcessEnvironment()方法。这里我们主要关注ConfigFileApplicationListener.postProcessEnvironment()方法。123456789101112public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { addPropertySources(environment, application.getResourceLoader()); configureIgnoreBeanInfo(environment); bindToSpringApplication(environment, application);}protected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) { RandomValuePropertySource.addToEnvironment(environment); // load方法才真正实现加载配置文件内容 new Loader(environment, resourceLoader).load();} 继续跟踪Loader.load()方法123456789101112131415161718192021222324252627282930313233343536public void load() { this.propertiesLoader = new PropertySourcesLoader(); this.activatedProfiles = false; this.profiles = Collections.asLifoQueue(new LinkedList&lt;Profile&gt;()); this.processedProfiles = new LinkedList&lt;Profile&gt;(); Set&lt;Profile&gt; initialActiveProfiles = initializeActiveProfiles(); this.profiles.addAll(getUnprocessedActiveProfiles(initialActiveProfiles)); if (this.profiles.isEmpty()) { for (String defaultProfileName : this.environment.getDefaultProfiles()) { Profile defaultProfile = new Profile(defaultProfileName, true); if (!this.profiles.contains(defaultProfile)) { this.profiles.add(defaultProfile); } } } this.profiles.add(null); while (!this.profiles.isEmpty()) { Profile profile = this.profiles.poll(); for (String location : getSearchLocations()) { if (!location.endsWith(\"/\")) { load(location, null, profile); } else { for (String name : getSearchNames()) { load(location, name, profile); } } } this.processedProfiles.add(profile); } addConfigurationProperties(this.propertiesLoader.getPropertySources());} 这里先不考虑profile的影响，直接看while循环里面且套的foreach循环，进入getSearchLocations()12345678910111213141516171819202122public static final String CONFIG_LOCATION_PROPERTY = \"spring.config.location\";private static final String DEFAULT_SEARCH_LOCATIONS = \"classpath:/,classpath:/config/,file:./,file:./config/\";private Set&lt;String&gt; getSearchLocations() { Set&lt;String&gt; locations = new LinkedHashSet&lt;String&gt;(); // 判断是否修改了配置文件的默认位置 if (this.environment.containsProperty(CONFIG_LOCATION_PROPERTY)) { for (String path : asResolvedSet( this.environment.getProperty(CONFIG_LOCATION_PROPERTY), null)) { if (!path.contains(\"$\")) { path = StringUtils.cleanPath(path); if (!ResourceUtils.isUrl(path)) { path = ResourceUtils.FILE_URL_PREFIX + path; } } locations.add(path); } } locations.addAll( asResolvedSet(ConfigFileApplicationListener.this.searchLocations, DEFAULT_SEARCH_LOCATIONS)); return locations;} 从DEFAULT_SEARCH_LOCATIONS可以看出，通常情况下，这个四个位置的配置文件会被默认加载。在回到load()方法里面的foreach循环，会执行123for (String name : getSearchNames()) { load(location, name, profile);} 在进入getSearchNames()方法12345678private static final String DEFAULT_NAMES = \"application\";private Set&lt;String&gt; getSearchNames() { if (this.environment.containsProperty(CONFIG_NAME_PROPERTY)) { return asResolvedSet(this.environment.getProperty(CONFIG_NAME_PROPERTY), null); } return asResolvedSet(ConfigFileApplicationListener.this.names, DEFAULT_NAMES);} 这里的ConfigFileApplicationListener.this.names是null，所以返回的就是DEFAULT_NAMES。所以，这就是为什么默认配置文件名称都是application。拿到文件名称后，在回到上面的forech方法，执行了load()方法，name即是文件名称12345678910111213141516171819202122232425private void load(String location, String name, Profile profile) { String group = \"profile=\" + ((profile != null) ? profile : \"\"); if (!StringUtils.hasText(name)) { loadIntoGroup(group, location, profile); } else { // 支持的文件类型是properties，xml，yml等文件格式 for (String ext : this.propertiesLoader.getAllFileExtensions()) { if (profile != null) { loadIntoGroup(group, location + name + \"-\" + profile + \".\" + ext, null); for (Profile processedProfile : this.processedProfiles) { if (processedProfile != null) { loadIntoGroup(group, location + name + \"-\" + processedProfile + \".\" + ext, profile); } } loadIntoGroup(group, location + name + \"-\" + profile + \".\" + ext, profile); } // 加载配置文件 loadIntoGroup(group, location + name + \".\" + ext, profile); } }} 再进入loadIntoGroup方法1234567891011121314151617181920212223242526272829303132333435private PropertySource&lt;?&gt; doLoadIntoGroup(String identifier, String location, Profile profile) throws IOException { Resource resource = this.resourceLoader.getResource(location); PropertySource&lt;?&gt; propertySource = null; StringBuilder msg = new StringBuilder(); if (resource != null &amp;&amp; resource.exists()) { String name = \"applicationConfig: [\" + location + \"]\"; String group = \"applicationConfig: [\" + identifier + \"]\"; propertySource = this.propertiesLoader.load(resource, group, name, (profile != null) ? profile.getName() : null); if (propertySource != null) { msg.append(\"Loaded \"); handleProfileProperties(propertySource); } else { msg.append(\"Skipped (empty) \"); } } else { msg.append(\"Skipped \"); } msg.append(\"config file \"); msg.append(getResourceDescription(location, resource)); if (profile != null) { msg.append(\" for profile \").append(profile); } if (resource == null || !resource.exists()) { msg.append(\" resource not found\"); this.logger.trace(msg); } else { this.logger.debug(msg); } return propertySource;} 可以看到这里是通过this.propertiesLoader.load()方法读取配置12345678910111213141516public PropertySource&lt;?&gt; load(Resource resource, String group, String name, String profile) throws IOException { if (isFile(resource)) { String sourceName = generatePropertySourceName(name, profile); for (PropertySourceLoader loader : this.loaders) { // 判断当前loader是否能读取该类型文件 if (canLoadFileExtension(loader, resource)) { PropertySource&lt;?&gt; specific = loader.load(sourceName, resource, profile); addPropertySource(group, specific); return specific; } } } return null;} 然后又通过loader.load()方法执行具体的读取逻辑123456public PropertySourcesLoader(MutablePropertySources propertySources) { Assert.notNull(propertySources, \"PropertySources must not be null\"); this.propertySources = propertySources; this.loaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class, getClass().getClassLoader());} 结合META-INF/spring.factories，可以看出loaders实际上PropertiesPropertySourceLoader和YamlPropertySourceLoader对象。 我们看下PropertiesPropertySourceLoader的load方法。12345678910public PropertySource&lt;?&gt; load(String name, Resource resource, String profile) throws IOException { if (profile == null) { Properties properties = PropertiesLoaderUtils.loadProperties(resource); if (!properties.isEmpty()) { return new PropertiesPropertySource(name, properties); } } return null;} 由PropertiesLoaderUtils.loadProperties()方法将配置文件中的内容读取写入到Properties对象里，到这里已经执行了Spring Boot对配置文件内容的读取。 总结整个源码分析的过程还是很长的，牵涉到很多的类，中间的关系还是有点复杂。不过如果第一遍看不懂的话，可以多看几遍，多跟踪几遍源码，每次你都会多明白一些原理，看到后面自然就明白其中的原理了。这里为了简化分析，忽略了其他一部分因素的影响，例如profile等。虽然看源码的过程比较枯燥繁琐，且懂不懂源码对业务开发没有明显的影响，但是如果你想突破自己，提升自己，阅读优秀源码是一门必修的课程。","link":"/2018/11/25/SpringBoot源码分析-配置文件加载原理/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"}],"categories":[{"name":"Maven","slug":"Maven","link":"/categories/Maven/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"}]}